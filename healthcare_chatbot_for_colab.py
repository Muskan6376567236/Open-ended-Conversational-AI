# -*- coding: utf-8 -*-
"""Healthcare Chatbot for Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TgtRQLG8twwYpCd6zh7BW9om6YW6HWIJ
"""

# Healthcare Consultation Chatbot
# This script combines all Python modules from the project document into a single file
# suitable for execution in a Google Colab environment.

# ==============================================================================
# 1. INSTALL DEPENDENCIES
# ==============================================================================
# In a Colab cell, run these commands first:
# !pip install transformers
# !pip install pycryptodome

print("Dependencies: Please run '!pip install transformers pycryptodome' in a Colab cell.")

# ==============================================================================
# 2. IMPORT LIBRARIES
# ==============================================================================
import requests
from datetime import datetime
import json
import base64
from Crypto.Cipher import AES

# Note: The 'transformers' library is large. We'll import it inside the function
# to make it clear where it's used and to avoid a long load time if only
# other parts of the script are used.

print("All libraries imported successfully.")

# ==============================================================================
# MODULE 1: NLP AND SYMPTOM ANALYSIS (from symptom_checker.py)
# ==============================================================================
# This module uses the Hugging Face transformers library to understand user input.

# Define a global variable for the NLP pipeline to avoid reloading the model.
NLP_PIPELINE = None

def initialize_nlp():
    """Initializes the NLP pipeline. This will download the model on first run."""
    global NLP_PIPELINE
    if NLP_PIPELINE is None:
        try:
            from transformers import pipeline
            print("Loading NLP model (distilbert-base-uncased)... This may take a moment.")
            # Note: Some models on Hugging Face might require authentication.
            # If you encounter a 401 Unauthorized error, you might need to log in
            # using `huggingface-cli login` in your terminal or provide a token
            # programmatically if the library supports it in the pipeline.
            NLP_PIPELINE = pipeline("text-classification", model="distilbert-base-uncased")
            print("NLP model loaded.")
        except ImportError:
            print("Transformers library not found. Please run '!pip install transformers'")
            return False
        except Exception as e:
            print(f"Error loading NLP model: {e}")
            return False
    return True

def detect_intent(user_input):
    """
    Sample intent classification. For this example, it will classify the text
    but a real-world application would use a model fine-tuned for medical intents.
    """
    if NLP_PIPELINE is None:
        if not initialize_nlp():
            return "Error: NLP model not initialized."

    try:
        result = NLP_PIPELINE(user_input)
        # The model returns a list, so we access the first element.
        return result[0]['label']
    except Exception as e:
        return f"Could not process intent: {e}"


def extract_symptoms(text):
    """Symptom extraction using a simple rule-based keyword search."""
    SYMPTOMS = ["fever", "cough", "headache", "fatigue", "shortness of breath", "dizzy"]
    # Return a list of symptoms found in the text (converted to lower case).
    return [sym for sym in SYMPTOMS if sym in text.lower()]

# ==============================================================================
# MODULE 2: WEARABLE DEVICE INTEGRATION (from wearable_integration.py)
# ==============================================================================
# This module simulates fetching data from a wearable device API like Fitbit.

def get_fitbit_data(access_token):
    """
    Fetches heart rate data from the Fitbit API.
    NOTE: This is a placeholder and requires a valid user access token to work.
    """
    if not access_token or access_token == "USER_ACCESS_TOKEN":
        print("Warning: Using mock Fitbit data. A real access token is needed.")
        # Return mock data for demonstration purposes.
        return {"activities-heart": [{"value": {"restingHeartRate": 75}}]}

    headers = {'Authorization': f'Bearer {access_token}'}
    url = "https://api.fitbit.com/1/user/-/activities/heart/date/today/1d.json"

    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Raise an exception for bad status codes (4xx or 5xx)
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"API request failed: {e}")
        return None

def process_heart_rate_data(api_data):
    """Extracts resting heart rate from Fitbit API response."""
    if api_data and 'activities-heart' in api_data and api_data['activities-heart']:
        return api_data['activities-heart'][0]['value'].get('restingHeartRate')
    return None

def health_alert(heart_rate):
    """Generates a simple health alert based on heart rate."""
    if heart_rate is None:
        return "Could not retrieve heart rate data."
    if heart_rate > 100:
        return "High heart rate detected. Please rest or consult a doctor."
    elif heart_rate < 50:
        return "Unusually low heart rate detected. Check for fatigue or dizziness."
    else:
        return "Heart rate is within a normal range."

# ==============================================================================
# MODULE 3: APPOINTMENT BOOKING SYSTEM (from appointment_manager.py)
# ==============================================================================
# A simple in-memory system to manage appointment scheduling.

# In-memory database for appointments
appointments = {}

def book_appointment(user, doctor, date_time):
    """Books an appointment for a user with a specific doctor."""
    if doctor not in appointments:
        appointments[doctor] = []

    # Check for existing appointments for the same user with the same doctor
    if any(appt['user'] == user for appt in appointments[doctor]):
         return {"status": "failed", "message": f"You already have an appointment with {doctor}."}

    appointments[doctor].append({"user": user, "time": date_time.isoformat()})
    print(f"Current appointments for {doctor}: {appointments[doctor]}")
    return {"status": "success", "message": f"Appointment booked with {doctor} on {date_time.strftime('%Y-%m-%d at %H:%M')}."}

def cancel_appointment(user, doctor):
    """Cancels an existing appointment."""
    if doctor in appointments:
        original_length = len(appointments[doctor])
        appointments[doctor] = [appt for appt in appointments[doctor] if appt.get('user') != user]
        if len(appointments[doctor]) < original_length:
            return {"status": "success", "message": "Appointment canceled."}

    return {"status": "failed", "message": "No appointment found to cancel."}

# ==============================================================================
# MODULE 4: CONTEXTUAL MEMORY (from context_manager.py)
# ==============================================================================
# Manages conversational context to provide personalized interactions.

class ContextManager:
    """A class to manage context for multiple users."""
    def __init__(self):
        self.user_context = {}

    def update_context(self, user, key, value):
        if user not in self.user_context:
            self.user_context[user] = {}
        self.user_context[user][key] = value
        print(f"Context updated for user '{user}': {key} = {value}")

    def get_context(self, user):
        return self.user_context.get(user, {})

# ==============================================================================
# MODULE 5: SECURITY AND PRIVACY (from security_layer.py)
# ==============================================================================
# Implements AES encryption to protect sensitive data.

# WARNING: A hardcoded key is insecure. In a real application, use a secure key management system.
KEY = b'SixteenByteKey!!'

def encrypt_data(data):
    """Encrypts data using AES in EAX mode."""
    try:
        cipher = AES.new(KEY, AES.MODE_EAX)
        nonce = cipher.nonce
        ciphertext, tag = cipher.encrypt_and_digest(data.encode('utf-8'))
        # Return nonce and ciphertext, both base64 encoded for safe storage/transmission
        return base64.b64encode(nonce).decode(), base64.b64encode(ciphertext).decode()
    except Exception as e:
        print(f"Encryption failed: {e}")
        return None, None


def decrypt_data(b64_nonce, b64_ciphertext):
    """Decrypts data using the provided nonce and ciphertext."""
    try:
        nonce = base64.b64decode(b64_nonce)
        ciphertext = base64.b64decode(b64_ciphertext)
        cipher = AES.new(KEY, AES.MODE_EAX, nonce=nonce)
        decrypted_data = cipher.decrypt(ciphertext)
        return decrypted_data.decode('utf-8')
    except (ValueError, KeyError, TypeError) as e:
        print(f"Decryption failed: {e}. The data may be corrupt or the key incorrect.")
        return None

# ==============================================================================
# MAIN EXECUTION BLOCK - DEMONSTRATION
# ==============================================================================
if __name__ == "__main__":
    print("\n" + "="*50)
    print(" HEALTHCARE CHATBOT DEMONSTRATION ".center(50, "="))
    print("="*50 + "\n")

    # --- Initialize components ---
    context_manager = ContextManager()
    current_user = "Sarthak"

    # --- 1. NLP Symptom Check ---
    print("\n--- Step 1: NLP Symptom Analysis ---")
    query = "I have been feeling dizzy and have a bad headache"
    print(f"User Query: '{query}'")

    # Initialize the NLP model (will download on first run)
    initialize_nlp()

    intent = detect_intent(query)
    symptoms = extract_symptoms(query)
    print(f"Detected Intent (Label): {intent}")
    print(f"Extracted Symptoms: {symptoms}")

    # Update context with the findings
    context_manager.update_context(current_user, "symptoms", symptoms)

    # --- 2. Wearable Data Check ---
    print("\n--- Step 2: Wearable Health Monitoring ---")
    fitbit_data = get_fitbit_data("USER_ACCESS_TOKEN") # Using mock data
    heart_rate = process_heart_rate_data(fitbit_data)
    alert_message = health_alert(heart_rate)
    print(f"Retrieved Resting Heart Rate: {heart_rate} bpm")
    print(f"Health Alert: {alert_message}")

    context_manager.update_context(current_user, "last_heart_rate", heart_rate)

    # --- 3. Appointment Booking ---
    print("\n--- Step 3: Appointment Management ---")
    doctor = "Dr. Melita"
    booking_time = datetime(2025, 10, 20, 14, 0)
    booking_result = book_appointment(current_user, doctor, booking_time)
    print(f"Booking Status: {booking_result['message']}")

    # --- 4. Data Encryption ---
    print("\n--- Step 4: Data Security ---")
    sensitive_info = "Patient diagnosis: migraine, based on reported headache and dizziness."
    print(f"Original Data: '{sensitive_info}'")

    nonce_b64, ciphertext_b64 = encrypt_data(sensitive_info)
    if nonce_b64:
        print(f"Encrypted Ciphertext (Base64): {ciphertext_b64[:30]}...") # Show a snippet

        decrypted_info = decrypt_data(nonce_b64, ciphertext_b64)
        print(f"Decrypted Data: '{decrypted_info}'")

    # --- 5. Review Context ---
    print("\n--- Step 5: Final User Context Review ---")
    final_context = context_manager.get_context(current_user)
    print(json.dumps(final_context, indent=2))

    print("\n" + "="*50)
    print(" DEMONSTRATION COMPLETE ".center(50, "="))
    print("="*50 + "\n")

!pip install transformers

!pip install pycryptodome

